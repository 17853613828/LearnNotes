<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>布局</title>
  <style>
    
    ul {
      border: 2px solid red;
      overflow: auto;
    }
    li {
      width: 200px;
      height: 200px;
      float: left;
      list-style: none;
    }
    .box1 {
      background-color: red;
    }
    .box2 {
      background-color: yellow;
    }
    .box3 {
      background-color: blue;
    }
    .box4 {
      background-color: green;
    }
    .box5 {
      background-color: purple;
    }
  </style>
</head>
<body>
  <ul>
    <li class="box1">1</li>
    <li class="box2">2</li>
    <li class="box3">3</li>
    <li class="box4">4</li>
    <li class="box5">5</li>
  </ul>
  <!-- 
    文档流(normal flow)
      —— 网页是一个多层的结构，一层摞着一层
      —— 通过css可以分别为每一层来设置样式
      —— 作为用户来讲只能看到最顶上一层
      —— 在这些层中，最底下的一层称为文档流，文档流是网页的基础，我们所创建的元素默认都是在文档流中进行排列
      —— 对于我们来说元素主要有两个状态：1.在文档流中 2.不在文档流中(脱离文档流)
  

    元素在文档流中有什么特点？？
      块元素：
        1. 块元素在页面中独占一行
        2. 默认宽度是父元素的全部(会把父元素撑满)
        3. 默认高度是被内容撑开(子元素)
      行内元素：
        1. 行内元素不会独占页面的一行，只占自身的大小
        2. 行内元素在页面中自左向右水平排列，如果一行之中不能容纳下所有的行内元素，
          则元素会换到第二行继续自左向右排列(书写习惯一致)
        3. 行内元素的默认宽度和高度都是被内容撑开
  -->


  <!-- 
    盒模型(box model)
      —— CSS将页面中的所有元素都设置为了一个矩形的盒子
      —— 将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位置
      —— 每一个盒子都有以下几个部分组成：内容区(content) \ 边框 border \ 内边距 padding \ 外边距 margin
      
    内边距
      —— 内容区和边框之间的距离是内边距
      —— 内边距的设置会影响到盒子的大小，背景颜色会延伸到内边距上
      —— 一个盒子的可见框的大小，由内容区、内边距、边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算 

    外边距
  -->


  <!-- 
    默认样式：
      —— 通常情况，浏览器都会为元素设置一些默认样式
      —— 默认样式的存在会影响到页面的布局，通常情况下编写网页时必须要去除浏览器的默认样式(PC端的页面)
  -->

  <!-- 
    默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定
    box-sizing 用来设置盒子尺寸的计算方式(设置width和height的作用)
      可选值：
        content-box —— 默认值，宽度和高度用来设置内容区的大小
        border-box —— 宽度和高度用来设置整个盒子可见框的大小，width 和 height 指的是内容区和内边距和边框的总和

  -->


  <!-- 
    outline 用来设置元素的轮廓线，用法和border一模一样，
    轮廓和边框不同的点，就是轮廓不会影响到可见框的大小
  -->


  <!-- 
    float
      通过浮动可以使一个元素向其父元素的左侧或右侧移动，使用float属性来设置子元素的浮动
      可选值：
        none 默认值，元素不浮动
        left 元素向左浮动
        right 元素向右浮动
      
      ！！！注意：
        1.元素设置浮动以后，水平布局的等式便不需要强制成立。
        2.元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，
          所以元素下边的还在文档流中的元素会自动向上移动。
        

      浮动的特点：
        1.浮动元素会完全脱离文档流，不再占据文档流中的位置
        2.设置浮动以后元素会向父元素的左侧或右侧移动
        3.浮动元素默认不会从父元素中移出
        4.浮动元素向左或向右移动时，不会超过它前面的其他浮动元素
        5.如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移
        6.浮动元素不会超过它上边的浮动的兄弟元素，最多就是和它一样高

        7.浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以利用浮动来设置文字环绕图片的效果
        8.元素设置浮动以后，将会从文档流中脱离，从文档流中脱离以后，元素的一些特点也会发生变化，


        脱离文档流的元素的特点：
          块元素：
            1.块元素不再独占页面的一行
            2.块元素的宽度和高度默认都被内容撑开

          行内元素：
            行内元素脱离文档里以后会变成块元素，特点和块元素一样

      简单总结：浮动主要作用就是让页面中的元素可以水平排列，
      通过浮动可以制作一些水平方向的布局
  -->


  <!-- 
    高度塌陷的问题：
      在浮动的布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离
      文档流，子元素从文档流中脱离，将会无法撑起父元素的高度，导致父元素的高度丢失

      父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱

      所以高度塌陷是浮动布局中比较常见的一个问题，这个问题我们必须进行处理！！
  -->


  <!-- 
    BFC(Block Formatting Context) 块级格式化环境
    BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC
    开启BFC该元素会变成一个独立的布局区域

    元素开启BFC后的特点：
      1.开启BFC的元素不会被浮动元素所覆盖
      2.开启BFC的元素子元素和父元素外边距不会重叠
      3.开启BFC的元素可以包含浮动的子元素

    可以通过设置一些特殊方式来开启元素的BFC：
      1.设置元素的浮动(不推荐)
      2.将元素设置为行内块元素inline-block(不推荐)
      3.将元素的overflow设置为一个非visible的值，
        ！！！常用的方式：为元素设置overflow: hidden 开启其BFC，以使其可以包含浮动元素
  -->


  <!-- 
    clear
      作用：清除浮动元素对当前元素所产生的影响
      可选值：
        left 清除左侧浮动元素对当前元素的影响
        right 清除右侧浮动元素对当前元素的影响
        both 清除两侧中最大影响的那侧

      原理：设置清除浮动以后，浏览器会自动为元素添加一个上外边距，
        以使其位置不受其他元素的影响
  -->


  <!-- 
    高度塌陷的最终解决方案：—— clearfix 这个样式可以同时解决高度塌陷和外边距重叠的问题，
      当你遇到这些问题时，直接使用clearfix这个类即可
    .clearfix::before,
    .clearfix::after {
      content: '';
      display: table;
      clear: both;
    }
  -->


  <!-- 
    定位(position)
      —— 定位是一种更加高级的布局手段
      —— 通过定位可以将元素摆放到页面的任意位置
      —— 使用position属性来设置定位
         可选值：
          static 默认值，元素是静止的没有开启定位
          relative 开启元素的相对定位
          absolute 开启元素的绝对定位
          fixed 开启元素的固定定位
          sticky 开启元素的粘滞定位

    相对定位
    绝对定位
    固定定位
    粘滞定位
      —— 当元素的position属性设置为sticky时则开启了元素的粘滞定位
      —— 粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置时将其固定
      —— 粘滞定位的兼容性不好，不支持IE浏览器


    对开启了定位的元素，可以通过z-index属性来执行元素的层级
    z-index需要一个整数作为参数，值越大元素的层级越高
    元素的层级越高越优先显示
    
    如果元素的层级一样时，则优先显示靠下的元素

    祖先元素的层级再高也不会盖住后代元素

  -->


  <!-- 
    将背景颜色值设置到内容区，边框和内边距不再有背景颜色
    background-clip: content-box

    
    background-clip 设置背景的范围
      可选值：
        border-box 默认值，背景会出现在边框的下边
        padding-box 背景不会出现在边框，只会出现在内容区和内边距
        content-box 背景只会出现在内容区

    background-origin 背景图片的偏移量计算的原点
      可选值：
        padding-box 默认值，background-position 从内边距处开始计算
        content-box 背景图片的偏移量从内容区处计算
        border-box 背景图片的变量从边框处开始计算

    background-attachment 背景图片是否跟随元素移动
      可选值：
        scroll 默认值 背景图片会跟随元素移动
        fixed 背景会固定在页面中，不会随元素移动

    background-color
    background-image
    background-repeat
    background-position
    background-size
    background-origin
    background-clip
    background-attachment
  -->


  <!-- 
    图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载，
    浏览器加载外部资源时是按需加载的，用则加载，不用则不加载

    案例：当我们为超链接a标签设置一个背景图片，鼠标移入时切换另一个背景，active后切换第三个背景，
    所以在没有缓存的情况下切换背景图片时可能会出现闪烁的情况，怎么解决？？？
    
    解决方案：雪碧图

    雪碧图的使用步骤：
      1.先确定要使用的图标
      2.测量图标的大小
      3.根据测量结果创建一个元素
      4.将雪碧图设置为元素的背景图片
      5.设置一个偏移量以显示正确的图片

    雪碧图的特点：
      一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户体验
   -->


  <!-- 
    通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果

    ！！！渐变是图片，需要通过background-image来设置

    线性渐变，颜色沿着一条直线发生变化 linear-gradient()
      1. 第一个参数可以指定一个渐变的方向 to left / to right / to bottom / to top / ...deg表示度数 / turn b表示圈
      2. 渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，也可以手动指定渐变的分布情况
      3. ....

    径向渐变，放射性效果 radial-gradient(大小 at 位置, 颜色 位置, 颜色 位置 )
      —— 默认情况下径向渐变的形状根据元素的形状来计算的(正方形 -> 圆形，长方形 -> 椭圆形)，
      我们也可以手动指定径向渐变的大小，circle ellipse

      —— 也可以指定渐变的位置
  -->


  <!-- 
    过渡(transition)
      —— 通过过渡可以指定一个属性发生变化时的切换方式
      —— 通过过渡可以创建一个非常好的效果，提升用户体验

    transition-property 指定要执行过渡的属性
      多个属性间使用逗号隔开
      如果所有属性都需要过渡，则使用all关键字
      大部分属性都指出过渡效果，注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡

    transition-duration 指定过渡效果的持续时间
    
    transition-timing-function  过渡的时序函数 指定过渡的执行的方式

    transition-delay
  -->

  
  <!-- 
    在不同的屏幕，单位像素的大小是不同的，像素越小屏幕会越清晰

    智能手机的像素点 远远小于 计算机的像素点

    问题：一个宽度为900px的网页在iphone6中要如何显示呢？
    
    默认情况下，移动端的网页都会将视口设置为980px(css像素)
    以确保pc端网页可以在移动端正常访问，但是如果网页的宽度超过了980，移动端的
    浏览器会自动对网页缩放以完整显示网页

    所以基本大部分的pc端网站都可以在移动端中正常浏览，但是往往都不会有一个好的体验，
    为了解决这个问题，大部分网站都会专门为移动端设计网页

    移动端默认的视口大小是980px(css像素)，默认情况下，移动端的像素比(css像素/物理像素)就是980/移动端宽度(980/750)，
    如果我们直接在网页中编写移动端代码，这样在980的视口下，像素比是非常不好的，导致网页中的内容非常非常的小

    编写移动页面时，必须要确保有一个比较合理的像素比，比如：
      1css像素 对应2个物理像素
      1css像素 对应3个物理像素

    可以通过meta标签来设置视口大小

    每一款移动设备设计时，都会有一个最佳的像素比，一般我们只需要将像素比设置为该值即可得到一个
    最佳效果，将像素比设置为最佳像素比的视口大小我们称其为完美视口

    将网页的视口设置为完美视口
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
     结论：以后再写移动端的页面，就把上面的这个写上
  -->


  <!-- 
    响应式布局
      网页可以根据不同的设备或窗口大小呈现出不同的效果
      使用响应式布局，可以使一个网页适用于所有设备
      响应式布局的关键就是媒体查询
      通过媒体查询，可以为不同的设备，或设备不同状态来分别设置样式

    媒体特性：
      width 视口的宽度
      height 视口的高度

      min-width 视口的最小宽度(视口大于指定宽度时生效)
      max-width 视口的最大宽度(视口小于指定宽度时生效)

    样式切换的分界点，我们称其为断电，也就是网页的样式会在这个点时发生变化
    一般比较常用的断点：
      小于 768 超小屏幕 max-width=768px
      大于768 小屏幕 min-width=768px
      大于992 中型屏幕 min-width=992px
      大于1200 大屏幕 min-width=1200px
  -->
</body>
<script>
  // 数组去重
  let arr = [1,2,3,4,6,3,2,2,4,1]

  function filterArr(arr) {
    let newArr = arr 
    
    for(var i = 0; i< newArr.length; i++) {
      for(var j = i + 1; j < newArr.length; j++) {
        if(newArr[i] === newArr[j]) {
          newArr.splice(j, 1);
          j--;
        }
      }
    }
    console.log(arr)
    return newArr
  } 

  console.log(filterArr(arr))
</script>
</html>