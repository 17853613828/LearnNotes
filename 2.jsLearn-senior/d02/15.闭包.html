<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>闭包</title>
</head>
<body>
  
</body>
<script>
  /*
    javasSript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。

    注意点：在函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，你实际上声明的是一个全局变量！
  */

  /*
    闭包：闭包就是能够读取其他函数内部变量的函数

    由于在JavasSript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成"定义在一个函数内部的函数"。
  */

  function f1(){
    var n = 999;
    return function f2(){
        // alert(n); // 999
        return n
    }
  }
  // f1()
  let n2 = f1()()
  console.log('n2=' +n2)

  /*
    在上面的代码中，函数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。

    这就是 JavasSript 语言特有的"链式作用域"结构（chain scope），

    子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
  */

  /*
    闭包的作用：
      一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除。

      为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，
    而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
  */

  /*
    闭包的注意点：
    （1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
      解决方法是，在退出函数之前，将不使用的局部变量全部删除。

    （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），
      把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
  */
</script>
</html>